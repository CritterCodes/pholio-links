/**
 * Server API for Domain Setup
 * 
 * This application runs on the private server (65.21.227.202)
 * It handles:
 * 1. Creating nginx configs for custom domains
 * 2. Generating SSL certificates via certbot
 * 3. Reloading nginx
 * 4. Sending webhook callbacks to the Vercel app
 * 
 * To set up on the server:
 * 1. Clone this to /opt/pholio/domain-setup-server
 * 2. npm install
 * 3. Create .env with DOMAIN_SETUP_SECRET and VERCEL_APP_URL
 * 4. sudo npm start (or use PM2/systemd service)
 * 
 * The app listens on port 3001 and requires sudo access for nginx/certbot
 */

import express from 'express';
import { exec } from 'child_process';
import { promisify } from 'util';
import crypto from 'crypto';
import fs from 'fs';
import path from 'path';
import dotenv from 'dotenv';

dotenv.config();

const app = express();
const execAsync = promisify(exec);
const writeFileAsync = promisify(fs.writeFile);
const mkdirAsync = promisify(fs.mkdir);

// Configuration
const DOMAIN_SETUP_SECRET = process.env.DOMAIN_SETUP_SECRET || 'your-secret-key-change-in-production';
const VERCEL_APP_URL = process.env.VERCEL_APP_URL || 'https://pholio.link';
const NGINX_SITES_DIR = '/etc/nginx/sites-available';
const LETSENCRYPT_DIR = '/etc/letsencrypt/live';
const PORT = 3001;

// Middleware
app.use(express.json());

// Verify request signature
const verifySignature = (body: string, signature: string): boolean => {
  const hash = crypto
    .createHmac('sha256', DOMAIN_SETUP_SECRET)
    .update(body)
    .digest('hex');
  return hash === signature;
};

interface DomainSetupRequest {
  domain: string;
  userId: string;
  webhookUrl: string;
  signature: string;
}

/**
 * Generate nginx config for a domain
 */
const generateNginxConfig = (domain: string): string => {
  return `# Auto-generated nginx config for ${domain}
# Generated on ${new Date().toISOString()}

# HTTP -> HTTPS redirect
server {
    listen 80;
    listen [::]:80;
    server_name ${domain} *.${domain};
    return 301 https://$host$request_uri;
}

# HTTPS reverse proxy
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name ${domain} *.${domain};

    # SSL certificate (generated by certbot)
    ssl_certificate ${LETSENCRYPT_DIR}/${domain}/fullchain.pem;
    ssl_certificate_key ${LETSENCRYPT_DIR}/${domain}/privkey.pem;
    ssl_trusted_certificate ${LETSENCRYPT_DIR}/${domain}/chain.pem;

    # SSL configuration
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    
    # HSTS
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;

    # Reverse proxy to Vercel
    location / {
        proxy_pass https://pholio.vercel.app;
        
        # Preserve original Host header (critical for Vercel)
        proxy_set_header Host $host;
        
        # Pass client IP information
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $server_name;
        
        # WebSocket support
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        
        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        
        # Don't buffer responses
        proxy_buffering off;
        
        # Allow large uploads
        client_max_body_size 100M;
    }

    # Health check endpoint (optional)
    location /_health {
        access_log off;
        return 200 "ok";
    }
}
`;
};

/**
 * Main domain setup endpoint
 */
app.post('/api/custom-domains/setup', async (req, res) => {
  try {
    const signature = req.get('X-Signature');
    const body = JSON.stringify(req.body);

    if (!signature || !verifySignature(body, signature)) {
      return res.status(401).json({ error: 'Invalid signature' });
    }

    const { domain, userId, webhookUrl } = req.body as DomainSetupRequest;

    // Validate input
    if (!domain || typeof domain !== 'string') {
      return res.status(400).json({ error: 'Invalid domain' });
    }

    const domainLower = domain.toLowerCase();

    // Prevent problematic domains
    if (domainLower.includes('pholio.link') || domainLower === 'bot.engelfinedesign.com') {
      return res.status(400).json({ error: 'Cannot set up this domain' });
    }

    console.log(`[Domain Setup] Starting setup for ${domainLower} (user: ${userId})`);

    try {
      // Step 1: Create nginx config file
      console.log(`[${domainLower}] Creating nginx config...`);
      const nginxConfig = generateNginxConfig(domainLower);
      const nginxPath = path.join(NGINX_SITES_DIR, domainLower);

      await execAsync(`sudo tee ${nginxPath}`, {
        input: nginxConfig,
      });

      // Enable site with symlink
      await execAsync(
        `sudo ln -sf ${nginxPath} /etc/nginx/sites-enabled/${domainLower}`
      );

      // Step 2: Test nginx config before reloading
      console.log(`[${domainLower}] Testing nginx config...`);
      await execAsync('sudo nginx -t');

      // Step 3: Generate SSL certificate with certbot
      console.log(`[${domainLower}] Generating SSL certificate...`);
      try {
        // Try with DNS challenge (preferred)
        await execAsync(
          `sudo certbot certonly --manual --preferred-challenges=dns -d "${domainLower}" -d "*.${domainLower}" --agree-tos --non-interactive --register-unsafely-without-email 2>/dev/null || true`
        );
      } catch (error) {
        // If DNS challenge fails, try HTTP challenge
        console.log(`[${domainLower}] DNS challenge failed, trying HTTP challenge...`);
        // For now, we'll use the self-signed cert as temporary
        await execAsync(
          `sudo mkdir -p ${LETSENCRYPT_DIR}/${domainLower} && sudo openssl req -x509 -nodes -days 90 -newkey rsa:2048 -keyout ${LETSENCRYPT_DIR}/${domainLower}/privkey.pem -out ${LETSENCRYPT_DIR}/${domainLower}/fullchain.pem -subj "/CN=${domainLower}" 2>/dev/null || true`
        );
      }

      // Step 4: Reload nginx
      console.log(`[${domainLower}] Reloading nginx...`);
      await execAsync('sudo systemctl reload nginx');

      // Step 5: Send webhook to Vercel app
      console.log(`[${domainLower}] Sending webhook callback...`);
      const webhookPayload = {
        userId,
        domain: domainLower,
        status: 'active',
        message: 'Domain successfully configured',
      };

      const webhookSignature = crypto
        .createHmac('sha256', DOMAIN_SETUP_SECRET)
        .update(JSON.stringify(webhookPayload))
        .digest('hex');

      try {
        await fetch(webhookUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Signature': webhookSignature,
          },
          body: JSON.stringify(webhookPayload),
        });
      } catch (webhookError) {
        console.error(`[${domainLower}] Webhook failed:`, webhookError);
        // Don't fail the whole setup if webhook fails
      }

      console.log(`[${domainLower}] ✓ Setup complete!`);

      res.json({
        success: true,
        domain: domainLower,
        message: `Domain ${domainLower} has been successfully set up!`,
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      console.error(`[${domainLower}] Setup failed:`, errorMessage);

      // Try to send error webhook
      const errorPayload = {
        userId,
        domain: domainLower,
        status: 'failed',
        error: errorMessage,
      };

      const errorSignature = crypto
        .createHmac('sha256', DOMAIN_SETUP_SECRET)
        .update(JSON.stringify(errorPayload))
        .digest('hex');

      try {
        await fetch(webhookUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Signature': errorSignature,
          },
          body: JSON.stringify(errorPayload),
        });
      } catch {
        // Ignore webhook errors
      }

      res.status(500).json({
        success: false,
        error: 'Failed to set up domain',
        details: errorMessage,
      });
    }
  } catch (error) {
    console.error('Request handler error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * Health check endpoint
 */
app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

/**
 * Start server
 */
app.listen(PORT, () => {
  console.log(`[Domain Setup Server] Listening on port ${PORT}`);
  console.log(`[Domain Setup Server] DOMAIN_SETUP_SECRET: ${DOMAIN_SETUP_SECRET ? '✓ Set' : '✗ Not set'}`);
  console.log(`[Domain Setup Server] VERCEL_APP_URL: ${VERCEL_APP_URL}`);
});
